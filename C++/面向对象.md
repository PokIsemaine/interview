# 面向对象

## 问题

### 基本认识

* 谈谈面向对象

* 简述一下 C++ 中的多态

* 简述下向上转型和向下转型

* 谈谈重载和重写？

* 谈谈多继承、菱形继承、虚继承

* C 语言如何实现多态、继承

* 对比组合与继承

### 类

* 说说什么是虚基类，可否被实例化？

* 如何理解抽象类？

* 说说类方法和数据的权限有哪几种？

* 请你回答一下 C++ 类内可以定义引用数据成员吗？

### 特殊成员函数

* 谈谈构造函数、析构函数的作用、特点、具体过程、异常、内联
* C++有哪几种的构造函数
* 委托构造函数的优缺点
* 构造函数里面可以调用成员函数吗
* nullptr 可以调用成员函数吗？
* 有参构造函数里面可以调用无参构造函数吗
* 谈谈成员初始化列表
* 说说一个空类，默认会生成哪些函数？
* 什么情况会自动生成默认构造函数？
* 什么时候需要合成拷贝构造函数呢？
* 如何禁止程序自动生成拷贝构造函数？
* 三之法则/五之法则/零之法则？
* 为什么拷贝构造函数必须传引用不能传值？
* 简述一下移动构造函数？
* 构造函数、拷贝构造函数和赋值操作符的区别？
* 什么时候会调用拷贝构造函数？
* 谈谈拷贝初始化与直接初始化？
* 解释一下什么是trivial destructor

### 虚函数

* C++ 中哪些函数不能被声明为虚函数？

* 虚析构函数的作用？

* 虚函数的代价？

* 虚函数表放在内存的什么区，其中的内容什么时候写进去的，虚表指针初始化时间，怎么查找虚函数的？

* 说说C++中虚函数与纯虚函数？

* 构造函数或析构函数中可以调用虚函数吗

### this 指针

* 谈谈 this 指针

* this指针是什么时候创建的？

* this指针存放在何处？堆、栈、全局变量，还是其他？

* this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”

* this指针是如何访问类中的变量的？

* 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

* 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

* this指针调用成员变量时，堆栈会发生什么变化？

* 如果在类的析构函数中调用delete this，会发生什么？

* 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

* 成员函数里memset(this,0,sizeof(*this))会发生什么

* 静态成员函数可以访问非静态的成员变量吗？

## 回答

### 基本认识

#### 谈谈面向对象？

面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示

**面向过程和面向对象的区别**

* 面向过程：根据业务逻辑从上到下写代码
* 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程

**面向对象的三大特征是封装、继承、多态。**

封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。

继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

三种继承方式

| **继承方式**        | **private继承** | **protected继承** | **public继承**               |
| ------------------- | --------------- | ----------------- | ---------------------------- |
| 基类的private成员   | 不可见          | 不可见            | 不可见                       |
| 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员            |
| 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为public成员仍为public成员 |

多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。

#### 简述一下 C++ 中的多态？

由于派生类重写基类方法，然后用基类引用指向派生类对象，调用方法时候会进行动态绑定，这就是多态。 多态分为静态多态和动态多态：

* 静态多态
  * 函数重载
  * 模板
  * CRTP
  * 函数指针 std::bind
* 动态多态：
  * 虚函数
  * std::variant & std::visit(C++17)

静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。

```cpp
include<iostream>
using namespace std;

int Add(int a,int b)//1
{
    return a+b;
}

char Add(char a,char b)//2
{
    return a+b;
}

int main()
{
    cout<<Add(666,888)<<endl;//1
    cout<<Add('1','2');//2
    return 0;
}
```

显然，第一条语句会调用函数1，而第二条语句会调用函数2，这绝不是因为函数的声明顺序，不信你可以将顺序调过来试试。

**动态多态：其实要实现动态多态，需要几个条件——即动态绑定条件：**

1. 虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
2. 通过基类类型的指针或引用来调用虚函数。

说到这，得插播一条概念：重写——也就是基类中有一个虚函数，而在派生类中也要重写一个原型（返回值、名字、参数）都相同的虚函数。不过协变例外。协变是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针。

```cpp
//协变测试函数
#include<iostream>
using namespace std;

class Base
{
public:
    virtual Base* FunTest()
    {
        cout << "victory" << endl;
        return this;
    }
};

class Derived :public Base
{
public:
    virtual Derived* FunTest()
    {
        cout << "yeah" << endl;
        return this;
    }
};

int main()
{
    Base b;
    Derived d;

    b.FunTest();
    d.FunTest();

    return 0;
}
```

#### 简述下向上转型和向下转型

子类转换为父类：向上转型，使用dynamic_cast<type_id>(expression)，这种转换相对来说比较安全不会有数据的丢失；

父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。

#### 谈谈重载和重写？

**重写**

是指派生类中存在重新定义的函数。**其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内）**，派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

示例如下：

```c++
#include<bits/stdc++.h>  
using namespace std;  
class A { 
 public:  virtual void fun()  {   cout << "A";  } 
}; 
class B :public A {
  public:  
  virtual void fun()  {   cout << "B";  } 
}; 
int main(void) {  
  A* a = new B();
  a->fun();//输出B，A类中的fun在B类中重写 
 }
```

 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

**重载**

我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。**函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。**

```plaintext
#include<bits/stdc++.h>
using namespace std;  
class A {  
 void fun() {};
 void fun(int i) {};
 void fun(int i, int j) {};     
 void fun1(int i,int j){}; 
};
```

**C++ 如何实现重载**

C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。

C++定义同名重载函数：

```plaintext
#include<iostream> 
using namespace std; 

int func(int a,double b) {
   return ((a)+(b)); 
} 
int func(double a,float b) {
   return ((a)+(b)); 
} 
int func(float a,int b) {
   return ((a)+(b)); 
} 
int main() {  
 return 0; 
}
```

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788124958/5E57B0F4AE72F40057C2EAA16C4DB902)

由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数。

**C 语言如何实现重载**

语言中不允许有同名函数，因为编译时函数命名是一样的，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：

使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能

重载函数使用可变参数，方式如打开文件open函数

gcc有内置函数，程序使用编译函数可以实现函数重载

```c
#include<stdio.h>   
void func_int(void * a) {
     printf("%d\n",*(int*)a);  //输出int类型，注意 void * 转化为int 
}   
void func_double(void * b) {     
 printf("%.2f\n",*(double*)b); 
}   

typedef void (*ptr)(void *);  //typedef申明一个函数指针   

void c_func(ptr p,void *param) {      
 p(param);                //调用对应函数 
}   
int main() {
     int a = 23;     
     double b = 23.23;     
     c_func(func_int,&a);     
     c_func(func_double,&b);     
     return 0; 
}
```

#### 谈谈多继承、菱形继承、虚继承

**多继承优缺点**

* C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。
* 多重继承的优点很明显，就是对象可以调用多个基类中的接口；
* 如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性
* 加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。
* 使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。

**菱形继承**

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788250019/669F46EC1CA09D9F687FFD9A8EC4CFEE)

假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。因为上述图表的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。现在，我们将上面的图表翻译成具体的代码：

```cpp
/*  *Animal类对应于图表的类A* */ 
class Animal { // 基类     
 int weight;      
public:     
 int getWeight() { return weight; } 
};  
 
class Tiger : public Animal { /* ... */ };
 
class Lion : public Animal { /* ... */ } 

class Liger : public Tiger, public Lion { /* ... */ }
```

在我们的继承结构中，我们可以看出Tiger和Lion类都继承自Animal基类。所以问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象"lg"会包含Animal基类的两个子对象。

所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用"lg.getWeight()"将会导致一个编译错误。这是因为编译器并不知道是调用Tiger类的getWeight()还是调用Lion类的getWeight()。所以，调用getWeight方法是不明确的，因此不能通过编译。

**虚继承**

我们给出了菱形继承问题的解释，但是现在我们要给出一个菱形继承问题的解决方案。如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建。看看下面的代码:

```cpp
class Tiger : virtual public Animal { /* ... */ }; 
class Lion : virtual public Animal { /* ... */ };
```

你可以看出唯一的变化就是我们在类Tiger和类Lion的声明中增加了"virtual"关键字。现在类Liger对象将会只有一个Animal子对象，下面的代码编译正常:

```cpp
int main( ) {  
 Liger lg;  /*既然我们已经在Tiger和Lion类的定义中声明了"virtual"关键字，于是下面的代码编译OK */  
 int weight = lg.getWeight(); 
}
```

虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题

```cpp
#include<iostream>
using namespace std;
class A{
public:
    int _a;
};
class B :virtual public A {
public:
    int _b;
};
class C :virtual public A {
public:
    int _c;
};
class D :public B, public C {
public:
    int _d;
};
//菱形继承和菱形虚继承的对象模型
int main() {
    D d;
    d.B::_a = 1;
    d.C::_a = 2;
    d._b = 3;
    d._c = 4;
    d._d = 5;
    cout << sizeof(D) << endl;
    return 0;
}
```

分别从菱形继承和虚继承来分析：

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788186868/1DBA188A576ED176E295873CC580363A)

菱形继承中A在B,C,D,中各有一份，虚继承中，A共享。

上面的虚继承表实际上是一个指针数组。B、C实际上是虚基表指针，指向虚基表。

虚基表：存放相对偏移量，用来找虚基类

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1565960190086.png)

![img](https://cdn.jsdelivr.net/gh/forthespada/mediaImage2@2.6/202104/C++-97-2.png)

**虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。**虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如上图所示。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。

#### C 语言如何实现多态、继承

```c
//C 语言模拟C++的继承与多态
typedef void (*FUN)();   //定义一个函数指针来实现对成员函数的继承

//父类
struct _A { 
  FUN _fun;  //由于C语言中结构体不能包含函数，故只能用函数指针在外面实现
  int _a;
};

//子类
struct _B {
  _A _a_;   //在子类中定义一个基类的对象即可实现对父类的继承
  int _b;
};

// 父类的同名函数
void _fA() {
  printf("_A:_fun()\n");
}

// 子类的同名函数
void _fB() {
  printf("_B:_fun()\n");
}

//C语言模拟继承与多态的测试
void Test() {
   
 _A _a;  //定义一个父类对象_a
   _B _b;  //定义一个子类对象_b
   _a._fun = _fA;    //父类的对象调用父类的同名函数
   _b._a_._fun = _fB;  //子类的对象调用子类的同名函数

 _A* p2 = &_a;  //定义一个父类指针指向父类的对象
 p2->_fun();   //调用父类的同名函数
 p2 = (_A*)&_b; //让父类指针指向子类的对象,由于类型不匹配所以要进行强转
 p2->_fun();   //调用子类的同名函数
}
```



c++的多态分为两种：

1. 编译时多态：重载

2. 运行时多态：重写即虚函数

思路就是使用函数指针来实现多态。

**编译时多态：**

先说一个c中的宏，`__V_ARGS__`，是c99引入进来的可变参宏，一般是用来输出debug信息。可以用这个宏实现一个简单的多态机制。代码举例：

```c
#define Check(...) printf(__VA_ARGS__);
int main(int argc, char *argv[])
{
    int i = 1, j = 2;
    char *Error = "error!!";
    Check("i = %d\n", j);
    Check("i = %d, j = %d\n", i, j);
    Check("i = %d, j = %d, Error:%s\n", i, j, Error);
	return 0;
}
/*********************关于结构体的*****************************/
#define func(...) myfunc((struct mystru) { __VA_ARGS__})

struct mystru
{
    const char *name;
    double d;
    int number;
};
 
void myfunc(struct mystru ms)
{
    printf("%s, %lf, %d\n", ms.name, ms.d, ms.number);
}
 
int main(int argc, char *argv[])
{
    func();
    func("hello", 1.1);
    func("hello");
    func("hello", 1.1, 100);
    func(.name = "hello");
    func(.d = 1.1);
    func(.number = 100);
    func(.d = 1.1, .name = "hello");
	return 0;
}
```

注意：一般我们在使用结构体的时候都是先赋值在传参数，这里实际上是用"..."可变参数替换为了`__VA_ARGS__`这个宏，然后转化为`(struct mystru){ __VA_ARGS__ }`，其实就是`
(struct mystru){ ... }` 。 通过（struct mystru）把参数转化结构体，这也是为什么如果我们不指定.name或者是.number时，必须按顺序传递参数，否则报错，因为在内存中结构体布局是确定的。不明确指定哪个参数只能按顺序传递。

**运行时多态：**

在c中sizeof(struct)是0,从内存上来看，c++的class和struct不仅仅有数据还有成员函数，这些成员函数如果是non-inline的，那么只会在内存中产生一份实例供所有对象使用，如果是inline的，会为每一个使用着产生一个实例。而c的struct就简单多了，它不占用内存空间，每一个实例按照struct分配一份就好，但这也是问题所在，它在内存中没实例啊。那么用c的struct实现时，我们就要想办法让它在内存中存在一份，大家都能找到它。

所以主要关键点就是在于函数指针的使用

```c++
//虚函数表结构
struct base_vtbl
{
	void(*dance)(void *);
	void(*jump)(void *);
};

//基类
struct base
{
    /*virtual table*/
	struct base_vtbl *vptr;
};
//基类的构造函数
struct base * new_base()
{
    struct base *temp = (struct base *)malloc(sizeof(struct base));
    //基类虚表结构中函数指针具体关联的函数名
	temp->vptr->dance = base_dance;
    temp->vptr->jump = base_jump;
	return temp;
}
//基类的成员函数
void base_dance()
{
	printf("base dance\n");
}
void base_jump()
{
	printf("base jump\n");
}


//派生类
struct derived1
{
	struct base super;
	int high;
};
//派生类的构造函数
struct derived1 * new_derived1(int h)
{
    struct derived1 * temp= (struct derived1 *)malloc(sizeof(struct derived1));
    //派生类虚表结构中函数指针具体关联的函数名
	temp->super->vptr->dance = derived1_table;
    temp->super->vptr->jump = derived1_jump;
	temp->high = h;
	return temp;
}
//派生类对象成员函数
void derived1_dance()
{
	printf("derived1 dance\n");
}
void derived1_jump(void * this)
{
	struct derived1* temp = (struct derived1 *)this;
	printf("derived1 jump:%d\n", temp->high);
}

/*******实际调用***********/
 struct base * bas = new_base();
//这里调用的是基类的成员函数
bas->vptr->dance();
bas->vptr->jump();

struct derived1 * child = new_derived1(100);
//基类指针指向派生类
bas  = (struct base *)child;

//这里调用的其实是派生类的成员函数
bas->vptr->dance();
bas->vptr->jump((void *)bas);
```







#### 说说什么是虚基类，可否被实例化？

在被继承的类前面加上virtual关键字，这时被继承的类称为虚基类，代码如下：

```cpp
class A
class B1:public virtual A;
class B2:public virtual A;
class D:public B1,public B2;
```

虚继承的类可以被实例化，举例如下：

```cpp
class Animal {/* ... */ };
class Tiger : virtual public Animal { /* ... */ };
class Lion : virtual public Animal { /* ... */ }
int main( )
{
    Liger lg;

    /*既然我们已经在Tiger和Lion类的定义中声明了"virtual"关键字，于是下面的代码编译OK */
    int weight = lg.getWeight();
}
```

#### 如何理解抽象类？

抽象类的定义如下：

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。

抽象类有如下几个特点：

* 抽象类只能用作其他类的基类，不能建立抽象类对象。
* 抽象类不能用作参数类型、函数返回类型或显式转换的类型。
* 可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。

抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。

1、抽象类的定义： 称带有纯虚函数的类为抽象类。

2、抽象类的作用： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。

3、 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。

抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。

4、纯虚函数定义 纯虚函数是一种特殊的虚函数，它的一般格式如下：

```plaintext
class <类名> 　{ 　virtual <类型><函数名>(<参数表>)=0; 　… 　}; 
```

　　在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。 　纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。

5、纯虚函数引入原因 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。 　为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）。若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 例如，绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 shape * 的数组，只要依次调用派生类的area()函数了。如果不用接口就没法定义成数组，因为既可以是circle ,也可以是square ,而且以后还可能加上rectangle，等等.

6、相似概念 1、多态性

指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 　a.编译时多态性：通过重载函数实现 　b.运行时多态性：通过虚函数实现。 2、虚函数 　虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。 3、抽象类 　包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。

#### 说说类方法和数据的权限有哪几种？

C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。

| **关键字** | **权限**                       |
| ---------- | ------------------------------ |
| public     | 可以被任意实体访问             |
| protected  | 只允许子类及本类的成员函数访问 |
| private    | 只允许本类的成员函数访问       |

类中的成员可以分为三种类型，分别为public成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。

1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。
2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。
3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。

#### 请你回答一下 C++ 类内可以定义引用数据成员吗？

c++类内可以定义引用成员变量，但要遵循以下三个规则：

1. 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
2. 构造函数的形参也必须是引用类型。
3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。

#### 对比组合与继承

**一：继承**

继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。

继承的优点：子类可以重写父类的方法来方便地实现对父类的扩展。

继承的缺点：

①：父类的内部细节对子类是可见的。

②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。

③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。

**二：组合**

组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。

组合的优点：

①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。

②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。

③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。

组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义。

### 特殊成员函数

#### 谈谈构造函数、析构函数的作用、特点、具体过程、异常、内联

**构造函数**

作用

构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。

构造函数顺序

① 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。

② 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。

③ 派生类构造函数。

1. 对象的vptr被初始化；
2. 如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；
3. 执行程序员所提供的代码；

C++构造函数的调用次序是：

基类的成员->基类的构造函数体->派生类的成员->派生类的构造函数体

几种关键字

* default 关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错
* delete 关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示

C++中的构造函数可以分为4类：

* 默认构造函数：有了有参的构造了，编译器就不提供默认的构造函数
* 初始化构造函数
* 拷贝构造函数：赋值构造函数默认实现的是值拷贝（浅拷贝）
* 移动构造函数

**析构函数**

析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。

析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。

每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。

类会在下面的情况析构

* 对象生命周期结束，被销毁时；
* delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时
* 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

析构函数顺序

1. 调用派生类的析构函数；
2. 调用成员类对象的析构函数；
3. 调用基类的析构函数。
4. 基类的成员析构

C++析构函数的调用次序是：

派生类的析构函数->派生类的成员析构->基类的析构函数->基类的成员析构

**是否能抛出异常**

* C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。
* 用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；
* 如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；
* 如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。

**是否能内联**

首先，将构造函数、析构函数、虚函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。

**构造函数和析构函数声明为内联函数是没有意义的**

《Effective C++》中所阐述的是：**将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简**。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。

**将虚函数声明为inline，要分情况讨论**

有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？

上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开

**综上**，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下。

#### C++有哪几种的构造函数

* 默认构造函数
* 初始化构造函数（有参数）
* 拷贝构造函数
* 移动构造函数（move和右值引用）
* 委托构造函数
* 转换构造函数

举个例子：

```c++
#include <iostream>
using namespace std;

class Student{
public:
    Student(){//默认构造函数，没有参数
        this->age = 20;
        this->num = 1000;
    };  
    Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表
    Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致
        this->age = s.age;
        this->num = s.num;
    }; 
    Student(int r){   //转换构造函数,形参是其他类型变量，且只有一个形参
        this->age = r;
        this->num = 1002;
    };
    ~Student(){}
public:
    int age;
    int num;
};

int main(){
    Student s1;
    Student s2(18,1001);
    int a = 10;
    Student s3(a);
    Student s4(s3);

    printf("s1 age:%d, num:%d\n", s1.age, s1.num);
    printf("s2 age:%d, num:%d\n", s2.age, s2.num);
    printf("s3 age:%d, num:%d\n", s3.age, s3.num);
    printf("s2 age:%d, num:%d\n", s4.age, s4.num);
    return 0;
}
//运行结果
//s1 age:20, num:1000
//s2 age:18, num:1001
//s3 age:10, num:1002
//s2 age:10, num:1002
```

* 默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作
* 复制构造函数用于复制本类的对象
* 转换构造函数用于将其他类型的变量，隐式转换为本类对象

#### 委托构造函数的优缺点

 在c++11中有一个新特性，就是委托构造函数。委托构造函数可以使用当前类的其他构造函数来帮助当前构造函数初始化。换而言之，就是可以将当前构造函数的部分(或者全部)职责交给本类的另一个构造函数。

我们先看看委托构造函数与普通构造函数的相同点与不同点。

相同点： 两者都有一个成员初始值列表与一个函数体

不同点：委托构造函数的**成员初始值列表**只有一个唯一的参数，就是构造函数(当然不能是当前的构造函数)

当被委托的构造函数的函数体中如果有代码，那么会先执行完函数体的代码，才会回到委托构造函数。在这里我们可以理解为一次函数调用（当然两者还是有些区别的）。

```c++
#include <iostream>
#include <string>
class A{
private:
    int _a;
    std::string _s;
public:
    // 普通构造函数
    A(std::string s, int a) : _a(a), _s(s){
        std::cout << "执行 普通构造函数 函数体" << std::endl;
    }
    // 委托构造函数
    A(int a): A("测试A(int a)", a){
        std::cout << "执行 委托构造函数A(int a) 函数体" << std::endl;
    }
    A(std::string s): A(s, 100){
        std::cout << "执行 委托构造函数A(std::string s) 函数体" << std::endl;
    }
    A(): A("测试A()", 4) { }
    A(std::ostream &out): A(){
        out << "我就是打酱油的\n";
    }
 
    // 打印对象内容
    void display() const{
        std::cout << "---------------------" << std::endl;
        std::cout << "s = " << _s << std::endl;
        std::cout << "a = " << _a << std::endl;
        std::cout << "---------------------" << std::endl;
    }
};
 
int main()
{
    A a("测试A(std::string s, int a)", 1);
    a.display();
 
    A b(2);
    b.display();
 
    A c("测试A(std::string s)");
    c.display();
    
    A d(std::cout);
    d.display();
    return 0;
}
```

优点：简化构造函数的书写，提高代码的可维护性，避免代码冗余膨胀

缺点：

* 一个委托构造函数想要委托另一个构造函数，那么被委托的构造函数应该包含较大数量的参数，初始化较多的成员变量。
* **在委托其他构造函数后，不能再进行成员列表初始化，而只能在函数体内对其他成员变量进行赋值。**并且只能委托一个构造函数，不能委托多个
* 不要形成委托坏。  在构造函数较多的时候，我们可能拥有多个委托构造函数，而一些目标构造函数很可能也是委托构造函数，这样依赖，我们就可能在委托构造函数中形成链状的委托构造关系，形成委托坏（Delegation Cycle）

#### 构造函数里面可以调用成员函数吗

在ctor中是可以调用其它member function的。

首先在一个类的所有非静态函数中，都隐藏了一个this指针。所以对ctor这个非静态函数来说，是存在此指针的。（证明了理论上是可以调用的）

至于楼主的意思，是怕在对象未全部构造完时就对其数据成员进行操作，这种考虑是正确的。所以，当你在ctor中调用member function时，务必不要在member function中使用（注意是使用，不包括赋值）未被ctor初始化过的数据成员。也就是说，这是在程序员的角度对这个调用进行把关。（证明了实践中的局限性）

所谓构造函数，就是给用户初始化变量的地方
实质上进入构造函数的时候，对象已经背分配了空间，虚表内容已经条重，只是私有空间当中的变量还没有初始化而已
成员函数对于一个类对象来说，始终是可以用，它和对象的构造没有关系，即便一个对象也没有，类的成员函数也是可以调用的，它在程序加载的时候就已经存在到内存当中了，无法在调用的时候this指针是否背赋予而已。构造函数背调用的时候，对象已经创立，this指针是月的

#### nullptr 可以调用成员函数吗？

能，因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。

```plaintext
//给出实例
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};
class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};
int main(){
    animal *pAn=nullptr;
    pAn->breathe();   // 输出：animal breathe haha
    fish *pFish = nullptr;
    pFish->breathe(); // 输出：fish bubble
    return 0;
}  
```

pAn->breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。

#### 有参构造函数里面可以调用无参构造函数吗

不能在构造函数体中调用其他的构造函数，这等于是临时构造了一个Teacher后又丢弃了它。

不过在新标准（C++11）中，可以在构造函数的构造初始化列表中调用本类的其他构造函数

#### 谈谈成员初始化列表

赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。

这两种方式的主要区别在于：

* 对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。
* 列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。

**效率**：方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。C++的赋值操作是会产生临时对象的，多了依次调用构造函数的过程，所以初始化列表要快一些。（对于内置类型没什么差别）

```c++
#include <iostream>
using namespace std;
class A {
public:
    A() {
        cout << "默认构造函数A()" << endl;
    }
    A(int a) {
        value = a;
        cout << "A(int "<<value<<")" << endl;
    }
    A(const A& a) {
        value = a.value;
        cout << "拷贝构造函数A(A& a):  "<<value << endl;
    }
    int value;
};

class B {
public:
    B() : a(1) {
        b = A(2);
    }
    A a;
    A b;
};
int main() {
    B b;
}

//输出结果：
//A(int 1)
//默认构造函数A()
//A(int 2)
```

从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但**如果有些成员是类**，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以**如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。**

**什么时候必须用用**

* 当初始化一个引用成员变量时；
* 初始化一个const成员变量时；（初始化列表是在编译的时候就指定了值，const成员不可以在运行的时候初始化）
* 当调用一个基类的构造函数，而构造函数拥有一组参数时
* 当调用一个成员类的构造函数，而他拥有一组参数；

**成员初始化列表做了什么**

* 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；
* list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；

#### 说说一个空类，默认会生成哪些函数?

**声明时[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)不会生成任何成员函数**

对于空类，声明时，编译器不会生成任何的成员函数，只会生成1个字节的占位符。
有时可能会以为编译器会为空类生成默认[构造函数](https://so.csdn.net/so/search?q=构造函数&spm=1001.2101.3001.7020)等，事实上是不会的，编译器只会在需要的时候生成6个成员函数：一个缺省的构造函数、一个拷贝构造函数、一个析构函数、一个赋值运算符、一对取址运算符和一个this指针
代码：

```c++
#include <iostream>
using namespace std;
 
class Empty_one {};
class Empty_two {};
class Empty_three {
    virtual void fun() = 0;//虚函数
};
class Empty_four :  public Empty_two, public Empty_three {};
 
int main() {
  cout<<"sizeof(Empty_one):"<<sizeof(Empty_one)<<endl;
  cout<<"sizeof(Empty_two):"<<sizeof(Empty_two)<<endl;
  cout<<"sizeof(Empty_three):"<<sizeof(Empty_three)<<endl;//有一个虚指针
  cout<<"sizeof(Empty_four):"<<sizeof(Empty_four)<<endl;
  return 0;
}

```

运行结果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190314151000624.png)

分析：

* 类Empty_one、Empty_two是空类，但空类同样可以被实例化，而每个实例在内存中都有一个独一无二的地址，为了达到这个目的，**编译器往往会给一个空类隐含的加一个字节**，这样空类在实例化后在内存得到了独一无二的地址，所以sizeof(Empty_one)和sizeof(Empty_two)的大小为1。
* 类Empty_three里面因有一个纯虚函数，故有一个指向虚函数的指针（vptr），64位系统分配给指针的大小为8个字节，所以sizeof(Empty_three)的大小为8。
* 类Empty_four继承于Empty_two和Empty_three，编译器取消Empty_two的占位符，保留一虚函数表，故大小为8。

**空类定义时会生成6个成员函数**

当空类Empty_one定义一个对象时Empty_one pt;sizeof(pt)仍是为1，但编译器会生成6个成员函数：

* 缺省的构造函数（无参）
* 拷贝构造函数
* 析构函数（非虚）
* 赋值运算符
* 两个取址运算符

```c++
class Empty
{
  public:
    Empty();                            //缺省构造函数
    Empty(const Empty &rhs);            //拷贝构造函数
    ~Empty();                           //析构函数 
    Empty& operator=(const Empty &rhs); //赋值运算符
    Empty* operator&();                 //取址运算符
    const Empty* operator&() const;     //取址运算符(const版本)
};

Empty *e = new Empty();    //缺省构造函数
delete e;                  //析构函数
Empty e1;                  //缺省构造函数                               
Empty e2(e1);              //拷贝构造函数
e2 = e1;                   //赋值运算符
Empty *pe1 = &e1;          //取址运算符(非const)
const Empty *pe2 = &e2;    //取址运算符(const)
```

#### 什么情况会自动生成默认构造函数？

* 如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；不过这个合成操作只有在构造函数真正被需要的时候才会发生；如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；
* 没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；
* 带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；
* 带有一个虚基类的类

需要注意的是：

* 默认构造不一定是合成的，也可以是用户自定义的

* 并不是任何没有构造函数的类都会合成一个构造函数
* 编译器合成出来的构造函数并不会显示设定类内的每一个成员变量
* 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。

#### 什么时候需要合成拷贝构造函数呢？

有三种情况会以一个对象的内容作为另一个对象的初值：

* 对一个对象做显示的初始化操作，X xx = x；
* 当对象被当做参数交给某个函数时；
* 当函数传回一个类对象时；

* 如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时 编译器会为该类合成一个拷贝构造函数；

* 如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；

* 如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝 构造函数；

 如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函 数；

#### 如何禁止程序自动生成拷贝构造函数？

* 为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要将他们设置成private，防止被调用。类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误

* C++的编译在链接之前，如果我们能在编译期解决这个问题，会节省不少的时间，要想在编译期解决问题，就需要人为制造一些bug。我们声明一个专门阻止拷贝的基类uncopyable。将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。接下来，我们的类只要继承uncopyable，如果要发生拷贝，编译器都会尝试调用基类的拷贝构造函数或者赋值运算符，但是因为这两者是私有的，会出现编译错误

 ```c++
 class uncopyable{
 protected:
     uncopyable(){}
     ~uncopyable(){}
 private:
     uncopyable(const uncopyable&);
     uncopyable& operator=(const uncopyable&);
 }
 ```

* 直接 delete

#### 三/五/零之法则

三之法则：如果某个类需要用户定义的析构函数、用户定义的复制构造函数或用户定义的复制赋值运算符，那么它几乎肯定需要全部三者。（只定义了析构函数，编译器将自动为我们生成拷贝构造函数和默认构造函数。）

五之法则：任何想要移动语义的类必须声明全部五个特殊成员函数 (析构函数、拷贝构造、赋值运算、移动拷贝构造、移动赋值运算)：

零之法则：有自定义析构函数、复制/移动构造函数或复制/移动赋值运算符的类应该专门处理所有权

当有意将某个基类用于多态用途时，可能需要将它的析构函数声明为公开的虚函数。由于这会阻拦隐式移动（并弃用隐式复制）的生成，因而必须将各特殊成员函数声明为预置的

#### 为什么拷贝构造函数必须传引用不能传值？

拷贝构造函数的参数必须使用引用传递

如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。

需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成Class(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。

#### 简述一下移动构造函数？

* 有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；
* 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；
* C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；
* 与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；

```c++
Example6 (Example6&& x) : ptr(x.ptr) {
    x.ptr = nullptr;
}

// move assignment
Example6& operator= (Example6&& x) {
   delete ptr; 
   ptr = x.ptr;
   x.ptr=nullptr;
    return *this;
}
```

**浅拷贝与深拷贝**

* 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。
* 深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。

深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现：

```cpp
STRING( const STRING& s )
{
    //_str = s._str;
    _str = new char[strlen(s._str) + 1];
    strcpy_s( _str, strlen(s._str) + 1, s._str );
}
STRING& operator=(const STRING& s)
{
    if (this != &s)
    {
        //this->_str = s._str;
        delete[] _str;
        this->_str = new char[strlen(s._str) + 1];
        strcpy_s(this->_str, strlen(s._str) + 1, s._str);
    }
    return *this;
}
```

这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？

![img](https://uploadfiles.nowcoder.com/images/20220225/4107856_1645788163127/9F844C99D8A154A32CA23995A7C1661B)

这种方法解决了我们的指针悬挂问题，通过不断的开空间让不同的指针指向不同的内存，以防止同一块内存被释放两次的问题。

#### 构造函数、拷贝构造函数和赋值操作符的区别

**构造函数**

对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数

**拷贝构造函数**

对象不存在，但是使用别的已经存在的对象来进行初始化

**赋值运算符**

对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的

* 拷贝构造函数是函数，赋值运算符是运算符重载。
* 拷贝构造函数会生成新的类对象，赋值运算符不能。
* 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。
* 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。

举个例子：

```c++
#include <iostream>
using namespace std;

class A {
public:
    A() { cout << "我是构造函数" << endl; }
    A(const A& a) { cout << "我是拷贝构造函数" << endl;}
    A& operator = (A& a) {
        cout << "我是赋值操作符" << endl;
        return *this;
    }
    ~A() {};
};

int main() {
    A a1; //调用构造函数
    A a2 = a1; //调用拷贝构造函数
    a2 = a1; //调用赋值操作符
    return 0;
}
//输出结果
//我是构造函数
//我是拷贝构造函数
//我是赋值操作符
```

#### 什么时候会调用拷贝构造函数？

* 用类的一个实例化对象去初始化另一个对象的时候
* 函数的参数是类的对象时（非引用传递）
* 函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数

**另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数**

**总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数**。

在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。

**在VS2019下进行下述实验：**

举个例子：

```plaintext
class A
{
public:
    A() {};
    A(const A& a)
    {
        cout << "copy constructor is called" << endl;
    };
    ~A() {};
};

void useClassA(A a) {}

A getClassA()//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数
{
    A a;
    return a;
}


//A& getClassA2()//  VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用
//{
//    A a;
//    return a;
//}


int main()
{
    A a1, a2,a3,a4;
    A a2 = a1;  //调用拷贝构造函数,对应情况1
    useClassA(a1);//调用拷贝构造函数，对应情况2
    a3 = getClassA();//发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3
    a4 = getClassA2(a1);//发生NRV优化，且引用返回自身，不会调用
    return 0;
}
```

情况1比较好理解

情况2的实现过程是，调用函数时先根据传入的实参产生临时对象，再用拷贝构造去初始化这个临时对象，在函数中与形参对应，函数调用结束后析构临时对象

情况3在执行return时，理论的执行过程是：产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象， 依然会调用拷贝构造函数

#### 谈谈拷贝初始化与直接初始化？

* 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数（有可能是拷贝构造函数），拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下

```plaintext
string str1("I am a string");//语句1 直接初始化
string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化
string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
```

* 为了提高效率，允许编译器跳过创建临时对象这一步，

 直接调用构造函数构造要创建的对象，这样就完全等价于

 直接初始化了

 （语句1和语句3等价），但是需要辨别两种情况。

* 当拷贝构造函数为private时：语句3和语句4在编译时会报错
* 使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

#### 解释一下什么是trivial destructor

“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。

反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数**如果申请了新的空间一定要显式的释放，否则会造成内存泄露**

对于trivial destructor，如果每次都进行调用，显然对效率是一种伤害，如何进行判断呢？

《STL源码解析》中给出的说明是：

> 首先利用value_type()获取所指对象的型别，再利用__type_traits判断该型别的析构函数是否trivial，若是(__true_type)，则什么也不做，若为(__false_type)，则去调用destory()函数

也就是说，在实际的应用当中，STL库提供了相关的判断方法**__type_traits**，感兴趣的读者可以自行查阅使用方式。除了trivial destructor，还有trivial construct、trivial copy construct等，如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效的完成相关操作，提升效率。

### 虚函数

#### 哪些函数不能是虚函数？

常见的不能声明为虚函数的有：

* 普通函数（非成员函数）
* 静态成员函数
* 内联成员函数
* 构造函数
* 友元函数。

**为什么C++不支持普通函数为虚函数？**

   普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。

**为什么C++不支持构造函数为虚函数？**

这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）

构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数

1. 从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）
2. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
3. 从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

**为什么C++不支持内联成员函数为虚函数？**

其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，*inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数*）

内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数

**为什么C++不支持静态成员函数为虚函数？**

这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。

静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别

**为什么C++不支持友元函数为虚函数？**

因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

#### 虚析构函数的作用

虚析构函数，是将基类的析构函数声明为virtual，举例如下：

```cpp
class TimeKeeper
{
public:    
    TimeKeeper() {}        
    virtual ~TimeKeeper() {}    
};
```

**虚析构函数的主要作用是防止内存泄露。**

定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。

如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。

1. 虚析构：将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。
2. 用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构
3. 用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

#### 虚函数的代价

* 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类；

* 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；

* 虚函数难以内联，因为内联函数在编译阶段进行替代，而虚函数在运行阶段才能确定到底是采用哪种函数，虚函数一般不是内联函数。

* Cache命中率不够好，一般函数可能编译后的指令就在当前函数地址附近，这样很可能在调用前目标函数代码已经被载入指令cache. 但是虚拟函数不在cache中的概率高。而且一调函数就可能在cache中载入虚函数表，如果这个虚函数又调用其它的虚函数，那么可能又得载入到cache中导致cache被占用，指令和数据的cache命中率下降

* 编译器不好优化。因为编译器只知道你要调用的是一个不确定的地址处的函数，没法知道更多细节，也就没法替你做更多优化

* 查找虚表有一定损耗（影响小）

#### 虚函数表放在内存的什么区，其中的内容什么时候写进去的，虚表指针初始化时间，怎么查找虚函数的？

虚表：

* 编译时构造完成，在构造函数执行之前
* 存储在只读数据段（.rodata)，也就是内存模型中的常量区

虚表指针：

* 在对类进行实例化，构造函数执行时对虚表指针进行初始化
* 存储在对象内存布局最前面，位于代码段(.text) ，也就是内存模型中的代码去

查找过程：

1.编译器会给每个虚函数指定一个在[虚函数表](https://www.zhihu.com/search?q=虚函数表&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1520718705})中的索引

2.在编译期，虚函数的调用以及被类似转化成`(*p->vptr[1])(p)` 这种形式，前面获取到func1的地址，然后调用，传的参数是p（表示this指针）。（假设func1函数是在索引1的位置，实际上从书中得知，虚函数表的第0位置存放的是type_info，虚函数都是从索引1的位置开始）

有人会问，虚函数调用在编译期转换成了`(*p->vptr[1])(p)` 这种形式，那岂不是写死了调用的是哪一个函数？但是在运行期才知道是调用的是基类还是子类的函数啊？  

这个问题其实是不存在的， `(*p->vptr[1])(p)` 这样只是在运行时告诉CPU，要去虚函数表索引为1的地方读取函数地址，这个函数的地址却不是编译期能确定的，因为可以b指针可以指向父类也可以指向子类。所以在运行时，  `vptr[1]`的值是根据运行时的具体指针指向情况确定的。 只不过，在编译期时已经确定了虚函数表中的每一项对应了每一个固定的虚函数。

例如例子中Base对象：

* Base对象的 func1 函数在虚函数表中的索引值是1
* Base对象的func2函数在虚函数表中的索引值是2

Child对象：

* func1函数在虚函数表中的索引值还是1.  继承自Base
* func2索引值还是2    继承自Base
* func3索引值是3    自己的虚函数

由上可见，其实无论是Base对象还是Child对象，虚函数 func1 在各自的虚函数表中的索引都是1.

**因此编译器便能把虚函数的调用在编译期就能直接替换成`(*p->vptr[1])(p)`这种形式**。

只不过如果指针指向的是Base对象，那么内存布局就是Base对象的内存，那么虚函数表中的vptr[1]存放的是Base自己的func1的地址；而如果指针指向的是Child对象，内存布局就是Child对象的内存，那么虚函数表中的vptr[1]存放的就是Child的func1函数的地址。

**分析**

虚函数表是全局共享的元素，即全局仅有一个，**在编译时就构造完成**

虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段

虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中

根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：

虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别

由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，**对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。**

一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区

C++中**虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。**



#### 说说C++中虚函数与纯虚函数？

1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。

2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。

3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。

4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。

5. 虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual { } = 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。

6. 纯虚函数不可以实例化，但是可以用其派生类实例化

 虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。即“纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”所以纯虚函数不能实例化。
7. 纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。
8. 定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。



#### 构造函数或析构函数中可以调用虚函数吗

在C++中，提倡不在构造函数和析构函数中调用虚函数；构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本

**构造函数**

不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。

因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编

派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。

所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。

**析构函数**

析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。



### this 指针

#### 谈谈 this 指针

* this指针是类的指针，指向对象的首地址。
* this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
* this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

**this指针的用处**

一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果。this作用域是在类内部，当在类的**非静态成员函数**中访问类的**非静态成员**的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行

**this指针的使用**

一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；

另外一种情况是当形参数与成员变量名相同时用于区分，如this->n = n （不能写成n = n）

**类的this指针有以下特点**

(1）**this**只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，**传入参数为当前对象地址，成员函数第一个参数为**为**T \* const this**

如：

```plaintext
class A{public:    int func(int p){}};
```

其中，**func**的原型在编译器看来应该是：

**int func(A \* const this,int p);**

（2）由此可见，**this**在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：

#### this指针是什么时候创建的？

this在成员函数的开始执行前构造，在成员的执行结束后清除。

但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答

#### this指针存放在何处？堆、栈、全局变量，还是其他？

this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。

#### this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”

大多数编译器通过ecx（计数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。

在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的

#### this指针是如何访问类中的变量的？

如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。

在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。

this是类的指针，如果换成结构体，那this就是结构的指针了。

#### 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

**this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。

> 感谢网友勘误：<https://github.com/forthespada/InterviewGuide/issues/10> ，标准情况下this为右值，无法通过&符号获取地址-2021.09.03

#### 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。

*感谢微信好友“铁锤哥哥”勘误：““成员函数默认第一个参数为”->建议写为：传入参数为当前对象地址，成员函数第一个参数为T \* const this-2021.06.28*

#### this指针调用成员变量时，堆栈会发生什么变化？

当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。

即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。

例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。

#### 如果在类的析构函数中调用delete this，会发生什么？

会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

#### 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。

#### 成员函数里memset(this,0,sizeof(*this))会发生什么

有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；

* 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；
* 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。

#### 静态成员函数可以访问非静态的成员变量吗？

静态成员函数不接受隐含的 this 自变量。所以，它就无法访问自己类的非静态成员

如何访问怎么办：在静态函数的形参表里加上实例的地址；入参的时候把对象的指针传进来
