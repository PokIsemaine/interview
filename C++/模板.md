# 模板

## 问题

### 基本认识

C++ 模板底层实现（编译过程）

模板和实现可不可以不写在一个文件里面？为什么？

为什么模板类一般都是放在一个h文件中

### 类模板和模板函数

* 解释下 C++ 中类模板和模板类的区别？
* 模板类是什么时候实现的
* 类模板和模板函数的区别
* 类模板中成员函数创建时机



## 可变参数模板

* va_list 原理 https://www.jianshu.com/p/5634469190a3
* 递归和非递归的参数包展开
* 可变参数宏和参数包如何实现





 模板类是编译时确定还是运行时确定

模板实例化发生在哪个阶段？实例化之后存在几份？ 

   一个模板类在不同特化之后，得到的类还是不是同一个类？

## 技巧

谈谈 SFINAE

谈谈 CRTP

## 回答

### 基本认识

#### C++ 模板底层实现（编译过程）

编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。

这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。

#### 模板和实现可不可以不写在一个文件里面？为什么？

因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。

但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。 《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间，

它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。



#### 为什么模板类一般都是放在一个h文件中

\1) 模板定义很特殊。由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。

所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。

 

\2) 在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。

所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。

然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。

### 类模板和模板函数

#### 解释下 C++ 中类模板和模板类的区别？

类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数

模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。

类模板的类型参数可以有一个或多个，每个类型前面都必须加class，如template <class T1,class T2>class someclass{…};在定义对象时分别代入实际的类型名，如  someclass<int,double> obj;

和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。

模板可以有层次，一个类模板可以作为基类，派生出派生模板类。





#### 类模板和模板函数的区别

函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加，而函数模板不必

类模板与函数模板区别主要有两点：

1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数（只有类模板可以）

类模板使用只能用显示指定类型方式

类模板中的模板参数列表可以有默认参数

#### 类模板中成员函数创建时机

类模板中成员函数和普通类中成员函数创建时机是有区别的：

- 普通类中的成员函数一开始就可以创建
- **类模板中的成员函数在调用时才创建**
