# 主从同步（复制）

[看一遍就了解：聊聊MySQL主从 - 掘金 (juejin.cn)](https://juejin.cn/post/7070290856967667742)

[高频面试：如何解决MySQL主从复制延时问题 - 掘金 (juejin.cn)](https://juejin.cn/post/7218948376166514745#heading-13)

## 问题

* 什么是数据库主从，有什么用
* 数据库主从复制原理
* 主主、主从、主备的区别
* MySQL 是怎么保证主从一致的
* 数据库主从延迟的原因与解决方案
* 数据库高可用

## 回答

### 什么是数据库主从，有什么用

**主从数据库**是什么意思呢，主是主库的意思，从是从库的意思。数据库主库对外提供读写的操作，从库对外提供读的操作。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83abaffb40cc4420906892e8d9beeb44~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**数据库为什么需要主从架构呢？**

- 高可用，实时灾备，用于故障切换。比如主库挂了，可以切从库。
- 读写分离，提供查询服务，减少主库压力，提升性能
- 备份数据，避免影响业务。



### 数据库主从复制原理

**主从复制原理**，简言之，分三步曲进行：

- 主数据库有个`bin log`二进制文件，纪录了所有增删改`SQL`语句。（binlog线程）
- 从数据库把主数据库的`bin log`文件的`SQL` 语句复制到自己的中继日志 `relay log`（io线程）
- 从数据库的`relay log`重做日志文件，再执行一次这些sql语句。（Sql执行线程）

详细的主从复制过程如图：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b28baac9e1b54d9a9e4b04ad648faeef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

上图主从复制过程分了五个步骤进行：

1. 主库的更新SQL(update、insert、delete)被写到binlog
2. 从库发起连接，连接到主库。
3. 此时主库创建一个`binlog dump thread`，把`bin log`的内容发送到从库。
4. 从库启动之后，创建一个`I/O`线程，读取主库传过来的`bin log`内容并写入到`relay log`
5. 从库还会创建一个SQL线程，从`relay log`里面读取内容，从`ExecMasterLog_Pos`位置开始执行读取到的更新事件，将更新内容写入到`slave`的db





### 主主、主从、主备的区别

**数据库主主**：两台都是主数据库，同时对外提供读写操作。客户端访问任意一台。数据存在双向同步。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cf239b2e8b04edca6cfa825111a0fb4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**数据库主从**：一台是主数据库，同时对外提供读写操作。一台是**从数据库，对外提供读的操作**。数据从主库同步到从库。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92ccbfd2ed84ed8b0c99f2fb5d65805~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

**数据库主备**：一台是主数据库，同时对外提供读写操作。一台是**备库，只作为备份作用，不对外提供读写，主机挂了它就取而代之**。数据从主库同步到备库。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1dd9d6e1bfe404398ac225e06d858ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

从库和备库，就是slave库功能不同因此叫法才不一样而已。一般slave库都会对外提供读的功能的，因此，大家日常听得比较多就是**主从**。



### MySQL 是怎么保证主从一致的

我们学习数据库的**主从复制原理**后，了解到**从库**拿到并执行主库的binlog日志，就可以保持数据与主库一致了。这是为什么呢？哪些情况会导致不一致呢？

####  长链接

主库和从库在同步数据的过程中断怎么办呢，数据不就会丢失了嘛。因此主库与从库之间维持了一个**长链接**，主库内部有一个线程，专门服务于从库的这个**长链接**的。

####  binlog格式

binlog 日志有三种格式，分别是`statement，row和mixed`。

如果是`statement`格式，binlog记录的是**SQL的原文**，如果主库和从库选的索引不一致，可能会导致主库不一致。我们来分析一下。假设主库执行删除这个SQL（其中`a和create_time`都有索引）如下：

```sql
delete from t where a > '666' and create_time<'2022-03-01' limit 1;
复制代码
```

我们知道，数据选择了`a`索引和选择`create_time`索引，最后`limit 1`出来的数据一般是不一样的。所以就会存在这种情况：在binlog = `statement`格式时，主库在执行这条SQL时，使用的是索引a，而从库在执行这条SQL时，使用了索引`create_time`。最后主从数据不一致了。

**如何解决这个问题呢？**

可以把binlog格式修改为`row`。`row`格式的`binlog`日志，记录的不是**SQL原文**，而是两个`event:Table_map 和 Delete_rows`。Table_map event说明要操作的表，Delete_rows event用于定义要删除的行为，记录删除的具体行数。`row`格式的binlog记录的就是要删除的主键ID信息，因此不会出现主从不一致的问题。

但是如果SQL删除10万行数据，使用row格式就会很占空间的，10万条数据都在binlog里面，写binlog的时候也很耗IO。但是`statement`格式的binlog可能会导致数据不一致，因此设计MySQL的大叔想了一个折中的方案，`mixed`格式的binlog。所谓的mixed格式其实就是`row`和`statement`格式混合使用，当MySQL判断可能数据不一致时，就用`row`格式，否则使用就用`statement`格式。





### 数据库主从延迟的原因与解决方案

#### 什么是主从延迟

**主从延迟**是怎么定义的呢？ 与主从数据同步相关的时间点有三个

1. 主库执行完一个事务，写入binlog，我们把这个时刻记为`T1`；
2. 主库同步数据给从库，从库接收完这个binlog的时刻，记录为`T2`；
3. 从库执行完这个事务，这个时刻记录为`T3`。

所谓主从延迟，其实就是指同一个事务，在从库执行完的时间和在主库执行完的时间差值，即`T3-T1`。

#### 主从延迟的原因

**哪些情况会导致主从延迟呢？**

1. 如果从库所在的机器比主库的**机器性能差，会导致主从延迟**，这种情况比较好解决，只需选择**主从库一样规格的机器**就好。
2. 如果**从库的压力大，也会导致主从延迟**。比如主库直接影响业务的，大家可能使用会**比较克制**，因此一般**查询都打到从库**了，结果导致从库查询消耗大量CPU，影响同步速度，最后导致主从延迟。这种情况的话，可以搞了**一主多从**的架构，即多接几个从库分摊读的压力。另外，还可以把binlog接入到Hadoop这类系统，让它们提供查询的能力。
3. **大事务也会导致主从延迟**。如果一个事务执行就要10分钟，那么主库执行完后，给到从库执行，最后这个事务可能就会导致从库延迟10分钟啦。日常开发中，我们为什么特别强调，不要一次性delete太多SQL，需要分批进行，其实也是为了避免大事务。另外，大表的DDL语句，也会导致大事务，大家日常开发关注一下哈。
4. **网络延迟**也会导致主从延迟，这种情况你只能优化你的网络啦，比如带宽20M升级到100M类似意思等。
5. 如果从**数据库过多**也会导致主从延迟，因此要避免复制的从节点数量过多。从库数据一般以3-5个为宜。
6. **低版本的MySQL**只支持单线程复制，如果主库并发高，来不及传送到从库，就会导致延迟。可以换用更高版本的Mysql，可以支持多线程复制。



#### 主从延迟的解决方案

我们一般会把从库落后的时间作为一个重点的数据库指标做监控和报警，正常的时间是在毫秒级别，一旦落后的时间达到了秒级别就需要告警了。

解决该问题的方法，除了缩短主从延迟的时间，还有一些其它的方法，基本原理都是尽量不查询从库，具体解决方案如下：

- **使用缓存**：我们在同步写数据库的同时，也把数据写到缓存，查询数据时，会先查询缓存，不过这种情况会带来 MySQL 和 Redis 数据一致性问题。
- **查询主库**：直接查询主库，这种情况会给主库太大压力，不建议这种方式。
- **数据冗余**：对于一些异步处理的场景，如果只扔数据 ID，消费数据时，需要查询从库，我们可以把数据全部都扔给消息队列，这样消费者就无需再查询从库。（这种情况应该不太能出现，数据转了一圈，MySQL 主从还没有同步好，直接去撕 DBA 吧）

在实际应用场景中，对于一些非常核心的场景，比如库存，支付订单等，需要直接查询主库，其它非核心场景，就不要去查主库了。





### 数据库高可用

- 双机主备高可用
- 一主一从
- 一主多从
- MariaDB同步多主机集群
- 数据库中间件

#### 双机主备高可用

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6355073a768f48e19ad171be64bb994e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

- **架构描述**：两台机器A和B，A为主库，负责读写，B为备库，只备份数据。如果A库发生故障，B库成为主库负责读写。修复故障后，A成为备库，主库B同步数据到备库A
- **优点**：一个机器故障了可以自动切换，操作比较简单。
- **缺点**：只有一个库在工作，读写压力大，未能实现读写分离，并发也有一定限制

#### 一主一从

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e44d62b86db4c14a3f526d15279faeb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

- **架构描述**: 两台机器A和B，A为主库，负责读写，B为从库，负责读数据。如果A库发生故障，B库成为主库负责读写。修复故障后，A成为从库，主库B同步数据到从库A。
- **优点**： 从库支持读，分担了主库的压力，提升了并发度。一个机器故障了可以自动切换，操作比较简单。
- **缺点**： 一台从库，并发支持还是不够，并且一共两台机器，**还是存在同时故障的机率，不够高可用**。

#### 一主多从

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d21e42b4a745ec8ff2777943819cf0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

- **架构描述**: 一台主库多台从库，A为主库，负责读写，B、C、D为从库，负责读数据。如果A库发生故障，B库成为主库负责读写，C、D负责读。修复故障后，A也成为从库，主库B同步数据到从库A。
- **优点**： 多个从库支持读，分担了主库的压力，明显提升了读的并发度。
- **缺点**： 只有台主机写，因此写的并发度不高

#### MariaDB同步多主机集群

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91edeaa545774026bdd0777f8247d115~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

- **架构描述**:有代理层实现负载均衡，多个数据库可以同时进行读写操作；各个数据库之间可以通过`Galera Replication`方法进行数据同步，每个库理论上数据是完全一致的。
- **优点**： 读写的并发度都明显提升，可以任意节点读写，可以自动剔除故障节点，具有较高的可靠性。
- **缺点**： 数据量不支持特别大。要避免大事务卡死，如果集群节点一个变慢，其他节点也会跟着变慢。

#### 数据库中间件

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/031d9e391d2c42dabeee33f1db613da0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

- 架构描述：mycat分片存储，每个分片配置一主多从的集群。
- 优点：解决高并发高数据量的高可用方案
- 缺点：维护成本比较大。



